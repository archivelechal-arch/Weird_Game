<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Mario-like Platformer</title>
  <style>
    :root{--bg:#87CEEB;--ground:#6B8E23;--player:#d33;--block:#8B5A2B}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Arial}
    #gameWrap{display:flex;flex-direction:column;height:100vh}
    canvas{background:linear-gradient(#87CEEB 0%, #bfe9ff 60%);display:block;box-shadow:0 10px 30px rgba(0,0,0,.15);margin:auto}
    header{padding:12px 18px;background:#0b79d0;color:white;font-weight:600}
    footer{padding:10px 12px;text-align:center;background:#f7f7f7;border-top:1px solid #e2e2e2}
    .controls{font-size:13px;opacity:.9}
    .credits{margin-top:6px;font-weight:700}
    a{color:#0b79d0}
  </style>
</head>
<body>
  <div id="gameWrap">
    <header>Mini Platformer — Gunakan ◀ ▶ untuk bergerak, SPACE untuk lompat</header>
    <main style="flex:1;display:flex;align-items:center;justify-content:center;padding:18px">
      <canvas id="game" width="900" height="480"></canvas>
    </main>
    <footer>
      <div class="controls"> Live Info: Tidak ada satu orang pun yang berhasil mencapai bendera di atas</div>
      <div class="credits"> Game Developer : <span id="creditName">Lechal Fiqh</span></div>
    </footer>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // Game state
  let keys = {};
  document.addEventListener('keydown', e=>{ keys[e.code]=true; });
  document.addEventListener('keyup', e=>{ keys[e.code]=false; });

  // Player
  const player = {
    x: 60, y: H-120, w: 34, h:44,
    vx:0, vy:0, speed:3.2, jump: -9.2, grounded:false
  };

  // Level layout (array of platforms)
  const platforms = [
    {x:0,y:H-40,w:W,h:40},
    {x:160,y:360,w:120,h:18},
    {x:320,y:300,w:120,h:18},
    {x:520,y:360,w:140,h:18},
    {x:720,y:260,w:120,h:18},
    {x:860,y:180,w:40,h:18},
  ];

  // Coins and goal
  let coins = [ {x:200,y:320, r:8, collected:false}, {x:360,y:260,r:8, collected:false}, {x:760,y:220,r:8, collected:false} ];
  const goal = {x:900-30, y:180-40, w:24, h:48};
  let score = 0;

  // Physics
  const gravity = 0.45;
  const friction = 0.86;

  function rectCollide(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function update(){
    // input
    if (keys['ArrowLeft'] || keys['KeyA']) player.vx = Math.max(player.vx - 0.5, -player.speed);
    if (keys['ArrowRight'] || keys['KeyD']) player.vx = Math.min(player.vx + 0.5, player.speed);
    if (!(keys['ArrowLeft']||keys['ArrowRight']||keys['KeyA']||keys['KeyD'])) player.vx *= friction;

    // jump
    if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.grounded){ player.vy = player.jump; player.grounded=false; }

    // apply gravity
    player.vy += gravity;
    player.x += player.vx;
    player.y += player.vy;

    // platform collisions
    player.grounded = false;
    for (let p of platforms){
      if (rectCollide(player,p)){
        // simple resolution: from top
        if (player.vy > 0 && player.y + player.h - player.vy <= p.y + 3){
          player.y = p.y - player.h;
          player.vy = 0;
          player.grounded = true;
        } else if (player.vy < 0 && player.y >= p.y + p.h - 2){
          player.y = p.y + p.h;
          player.vy = 0;
        } else {
          // side collision
          if (player.x < p.x) player.x = p.x - player.w;
          else player.x = p.x + p.w;
          player.vx = 0;
        }
      }
    }

    // coin collisions
    for (let c of coins){
      if (!c.collected){
        const dx = (player.x + player.w/2) - c.x;
        const dy = (player.y + player.h/2) - c.y;
        const dist = Math.sqrt(dx*dx+dy*dy);
        if (dist < c.r + Math.max(player.w, player.h)/2 - 6){ c.collected = true; score += 100; }
      }
    }

    // goal check
    if (player.x + player.w > goal.x && player.y + player.h > goal.y && player.y < goal.y + goal.h){
      // win: reset level and keep score
      resetLevel(true);
    }

    // keep in bounds
    if (player.y > H+100){ resetLevel(false); }
  }

  function resetLevel(won){
    player.x = 60; player.y = H-120; player.vx=0; player.vy=0; player.grounded=false;
    coins.forEach(c=>c.collected=false);
    if (won) score += 500; // bonus
  }

  function drawPlayer(){
    // simple 'mario-like' blocky character (no trademarked sprite)
    const p = player;
    // legs
    ctx.fillStyle = '#222'; ctx.fillRect(p.x+6, p.y+p.h-12, 10, 12); ctx.fillRect(p.x+p.w-16, p.y+p.h-12, 10, 12);
    // body
    ctx.fillStyle = '#d33'; ctx.fillRect(p.x+4, p.y+6, p.w-8, 20);
    // head
    ctx.fillStyle = '#ffcc99'; ctx.fillRect(p.x+6, p.y-6, p.w-12, 16);
    // hat
    ctx.fillStyle = '#d33'; ctx.fillRect(p.x+2, p.y-10, p.w-4, 6);
  }

  function draw(){
    // background sky gradient already set by css but we clear
    ctx.clearRect(0,0,W,H);

    // draw parallax clouds (simple)
    for (let i=0;i<6;i++){
      const cx = (i*180 + (Date.now()/60)%180);
      ctx.globalAlpha = 0.6; ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.ellipse((cx)%W, 80 + (i%2)*10, 36,20,0,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    // platforms
    for (let p of platforms){
      ctx.fillStyle = '#8B5A2B'; ctx.fillRect(p.x, p.y, p.w, p.h);
      // top highlight
      ctx.fillStyle = '#c09060'; ctx.fillRect(p.x+2, p.y, p.w-4, 4);
    }

    // coins
    for (let c of coins){
      if (c.collected) continue;
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.beginPath(); ctx.ellipse(0,0,c.r,c.r*0.8,0,0,Math.PI*2);
      ctx.fillStyle = 'gold'; ctx.fill();
      ctx.restore();
    }

    // goal (flag)
    ctx.fillStyle = '#333'; ctx.fillRect(goal.x, goal.y, 6, goal.h);
    ctx.fillStyle = '#ff0000'; ctx.fillRect(goal.x+6, goal.y+6, 18, 12);

    // player
    drawPlayer();

    // HUD
    ctx.fillStyle = '#111'; ctx.font = '18px ui-rounded, system-ui, Arial';
    ctx.fillText('Score: ' + score, 14, 28);

    // small instructions when low on score
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = '#00000033'; ctx.fillRect(W-220,10,210,36);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff'; ctx.font = '13px sans-serif'; ctx.fillText('Use ◀ ▶ / A D = move, SPACE = jump', W-206, 32);
  }

  function loop(){ update(); draw(); requestAnimationFrame(loop); }

  // touch controls (mobile)
  function createTouchButtons(){
    const left = document.createElement('button'); const right = document.createElement('button'); const jump = document.createElement('button');
    left.textContent='◀'; right.textContent='▶'; jump.textContent='↑';
    Object.assign(left.style,{position:'fixed',left:'10px',bottom:'70px',width:'54px',height:'54px',fontSize:'24px',opacity:0.6});
    Object.assign(right.style,{position:'fixed',left:'80px',bottom:'70px',width:'54px',height:'54px',fontSize:'24px',opacity:0.6});
    Object.assign(jump.style,{position:'fixed',right:'10px',bottom:'70px',width:'64px',height:'54px',fontSize:'20px',opacity:0.6});
    document.body.appendChild(left); document.body.appendChild(right); document.body.appendChild(jump);
    left.addEventListener('touchstart', e=>keys['ArrowLeft']=true); left.addEventListener('touchend', e=>keys['ArrowLeft']=false);
    right.addEventListener('touchstart', e=>keys['ArrowRight']=true); right.addEventListener('touchend', e=>keys['ArrowRight']=false);
    jump.addEventListener('touchstart', e=>keys['Space']=true); jump.addEventListener('touchend', e=>keys['Space']=false);
  }

  // init
  window.addEventListener('load', ()=>{
    // if user wants to change credit name in-page, they can edit HTML or use console: setCredit('Nama Kamu')
    window.setCredit = name => { document.getElementById('creditName').textContent = name; };
    // mobile detect for touch buttons
    if ('ontouchstart' in window) createTouchButtons();
    loop();
  });

})();
</script>
</body>
</html>
